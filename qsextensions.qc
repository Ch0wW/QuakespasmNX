/*
Extensions file for QuakeSpasm 0.92.2-spiked-r5
This file is auto-generated by pr_dumpplatform with no args.
You will probably need to use FTEQCC to compile this.
*/


//QuakeSpasm only supports ssqc, so including this file in some other situation is a user error
#if defined(QUAKEWORLD) || defined(CSQC) || defined(MENU)
#error Mixed up module defs
#endif


//List of advertised extensions
//DP_ENT_ALPHA
//DP_CON_SET
//DP_CON_SETA
//DP_EF_NOSHADOW
//DP_QC_AUTOCVARS
//DP_QC_ASINACOSATANATAN2TAN
//DP_QC_COPYENTITY
//DP_QC_CRC16
//DP_QC_CVAR_DEFSTRING
//DP_QC_CVAR_STRING
//DP_QC_CVAR_TYPE
//DP_QC_EDICT_NUM
//DP_QC_ENTITYDATA
//DP_QC_ETOS
//DP_QC_FINDCHAIN
//DP_QC_FINDCHAINFLAGS
//DP_QC_FINDCHAINFLOAT
//DP_QC_FINDFLAGS
//DP_QC_FINDFLOAT
//DP_QC_GETSURFACE
//DP_QC_GETSURFACETRIANGLE
//DP_QC_GETSURFACEPOINTATTRIBUTE
//DP_QC_MINMAXBOUND
//DP_QC_MULTIPLETEMPSTRINGS
//DP_QC_RANDOMVEC
//DP_QC_SINCOSSQRTPOW
//DP_QC_STRFTIME
//DP_QC_STRING_CASE_FUNCTIONS
//DP_QC_STRINGBUFFERS
//DP_QC_STRREPLACE
//DP_QC_TOKENIZEBYSEPARATOR
//DP_QC_TRACEBOX
//DP_QC_TRACETOSS
//DP_QC_TRACE_MOVETYPES
//DP_QC_URI_ESCAPE
//DP_QC_VECTOANGLES_WITH_ROLL
//DP_QC_VECTORVECTORS
//DP_QC_WHICHPACK
//DP_REGISTERCVAR
//DP_SV_BOTCLIENT
//DP_SV_DROPCLIENT
//DP_SV_POINTSOUND
//DP_SV_SETCOLOR
//DP_SV_SPAWNFUNC_PREFIX
//DP_SV_WRITEUNTERMINATEDSTRING
//DP_TE_BLOOD
//DP_TE_STANDARDEFFECTBUILTINS
//EXT_BITSHIFT
//FRIK_FILE
//FTE_PART_SCRIPT
//FTE_PART_NAMESPACES
//FTE_PART_NAMESPACE_EFFECTINFO
//FTE_QC_CHECKCOMMAND
//FTE_QC_INTCONV
//FTE_SV_POINTPARTICLES
//KRIMZON_SV_PARSECLIENTCOMMAND
//ZQ_QC_STRINGS


//Explicitly flag this stuff as probably-not-referenced, meaning fteqcc will shut up about it and silently strip what it can.
#pragma noref 1


//Some custom types (that might be redefined as accessors by fteextensions.qc, although we don't define any methods here)
#ifdef _ACCESSORS
accessor strbuf:float;
accessor searchhandle:float;
accessor hashtable:float;
accessor infostring:string;
accessor filestream:float;
#else
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
#endif


//Supported Extension fields
.float gravity;
//.float items2;			/*if defined, overrides serverflags for displaying runes on the hud*/
.float alpha;				/*entity opacity*/
.float traileffectnum;		/*can also be set with 'traileffect' from a map editor*/
.float emiteffectnum;		/*can also be set with 'traileffect' from a map editor*/
.vector movement;			/*describes which forward/right/up keys the player is holidng*/
.entity viewmodelforclient;	/*attaches this entity to the specified player's view. invisible to other players*/


//Supported Extension Constants
const float MOVETYPE_FOLLOW	= 12;
const float SOLID_CORPSE	= 5;
const float FILE_READ		= 0;
const float FILE_APPEND		= 1;
const float FILE_WRITE		= 2;
const float CLIENTTYPE_DISCONNECT	= 0;
const float CLIENTTYPE_REAL			= 1;
const float CLIENTTYPE_BOT			= 2;
const float CLIENTTYPE_NOTCLIENT	= 3;
const float EF_NOSHADOW		= 0x1000;
const float MSG_MULTICAST	= 4;
const float MULTICAST_ALL	= MULTICAST_ALL_U;
const float MULTICAST_PVS	= MULTICAST_PVS_U;
const float MULTICAST_ONE	= MULTICAST_ONE_U;
const float MULTICAST_ALL_R	= MULTICAST_ALL_R;
const float MULTICAST_PVS_R	= MULTICAST_PVS_R;
const float MULTICAST_ONE_R	= MULTICAST_ONE_R;
const float MULTICAST_INIT	= MULTICAST_INIT;


//Builtin list
vector(vector fwd, optional vector up) vectoangles2 = #51; /*
		Returns the angles (+x=UP) required to orient an entity to look in the given direction. The 'up' argument is required if you wish to set a roll angle, otherwise it will be limited to just monster-style turning. */

float(float angle) sin = #60;
float(float angle) cos = #61;
float(float value) sqrt = #62;
void(entity ent, entity ignore) tracetoss = #64;
string(entity ent) etos = #65;
string(entity e, string key) infokey = #80; /*
		If e is world, returns the field 'key' from either the serverinfo or the localinfo. If e is a player, returns the value of 'key' from the player's userinfo string. There are a few special exceptions, like 'ip' which is not technically part of the userinfo. */

float(string) stof = #81;
#define unicast(pl,reli) do{msg_entity = pl; multicast('0 0 0', reli?MULITCAST_ONE_R:MULTICAST_ONE);}while(0)
void(vector where, float set) multicast = #82; /*
		Once the MSG_MULTICAST network message buffer has been filled with data, this builtin is used to dispatch it to the given target, filtering by pvs for reduced network bandwidth. */

void(vector start, vector mins, vector maxs, vector end, float nomonsters, entity ent) tracebox = #90; /*
		Exactly like traceline, but a box instead of a uselessly thin point. Acceptable sizes are limited by bsp format, q1bsp has strict acceptable size values. */

vector() randomvec = #91; /*
		Returns a vector with random values. Each axis is independantly a value between -1 and 1 inclusive. */

vector(vector org) getlight = #92;
float(string cvarname, string defaultvalue) registercvar = #93; /*
		Creates a new cvar on the fly. If it does not already exist, it will be given the specified value. If it does exist, this is a no-op.
		This builtin has the limitation that it does not apply to configs or commandlines. Such configs will need to use the set or seta command causing this builtin to be a noop.
		In engines that support it, you will generally find the autocvar feature easier and more efficient to use. */

float(float a, float b, ...) min = #94; /*
		Returns the lowest value of its arguments. */

float(float a, float b, ...) max = #95; /*
		Returns the highest value of its arguments. */

float(float minimum, float val, float maximum) bound = #96; /*
		Returns val, unless minimum is higher, or maximum is less. */

float(float value, float exp) pow = #97;
#define findentity findfloat
entity(entity start, .__variant fld, __variant match) findfloat = #98; /*
		Equivelent to the find builtin, but instead of comparing strings contents, this builtin compares the raw values. This builtin requires multiple calls in order to scan all entities - set start to the previous call's return value.
		world is returned when there are no more entities. */

float(string extname) checkextension = #99; /*
		Checks for an extension by its name (eg: checkextension("FRIK_FILE") says that its okay to go ahead and use strcat).
		Use cvar("pr_checkextension") to see if this builtin exists. */

float(__variant funcref) checkbuiltin = #0; /*
		Checks to see if the specified builtin is supported/mapped. This is intended as a way to check for #0 functions, allowing for simple single-builtin functions. */

float(string builtinname) builtin_find = #100; /*
		Looks to see if the named builtin is valid, and returns the builtin number it exists at. */

float(float value) anglemod = #102;
filestream(string filename, float mode, optional float mmapminsize) fopen = #110; /*
		Opens a file, typically prefixed with "data/", for either read or write access. */

void(filestream fhandle) fclose = #111;
string(filestream fhandle) fgets = #112; /*
		Reads a single line out of the file. The new line character is not returned as part of the string. Returns the null string on EOF (use if not(string) to easily test for this, which distinguishes it from the empty string which is returned if the line being read is blank */

void(filestream fhandle, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) fputs = #113; /*
		Writes the given string(s) into the file. For compatibility with fgets, you should ensure that the string is terminated with a \n - this will not otherwise be done for you. It is up to the engine whether dos or unix line endings are actually written. */

#define ftell fseek //c-compat
int(filestream fhandle, optional int newoffset) fseek = #0; /*
		Changes the current position of the file, if specified. Returns prior position, in bytes. */

float(string s) strlen = #114;
string(string s1, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7, optional string s8) strcat = #115;
string(string s, float start, float length) substring = #116;
vector(string s) stov = #117;
string(string s, ...) strzone = #118; /*
		Create a semi-permanent copy of a string that only becomes invalid once strunzone is called on the string (instead of when the engine assumes your string has left scope). */

void(string s) strunzone = #119; /*
		Destroys a string that was allocated by strunzone. Further references to the string MAY crash the game. */

float(float number, float quantity) bitshift = #218;
void(vector org) te_lightningblood = #219;
float(string s1, string sub, optional float startidx) strstrofs = #221; /*
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /*
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /*
		The input floats are considered character values, and are concatenated. */

string(float pad, string str1, ...) strpad = #225; /*
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /*
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /*
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /*
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string(string s) strtrim = #0; /*
		Trims the whitespace from the start+end of the string. */

void(vector org, float count) te_bloodqw = #239;
float(float a, float n) mod = #245;
int(string) stoi = #259; /*
		Converts the given string into a true integer. Base 8, 10, or 16 is determined based upon the format of the string. */

string(int) itos = #260; /*
		Converts the passed true integer into a base10 string. */

int(string) stoh = #261; /*
		Reads a base-16 string (with or without 0x prefix) as an integer. Bugs out if given a base 8 or base 10 string. :P */

string(int) htos = #262; /*
		Formats an integer as a base16 string, with leading 0s and no prefix. Always returns 8 characters. */

int(float) ftoi = #0; /*
		Converts the given float into a true integer without depending on extended qcvm instructions. */

float(int) itof = #0; /*
		Converts the given true integer into a float without depending on extended qcvm instructions. */

#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
vector(vector v1, vector v2) crossproduct = #0; /*
		Small helper function to calculate the crossproduct of two vectors. */

float(float modidx, string framename) frameforname = #276; /*
		Looks up a framegroup from a model by name, avoiding the need for hardcoding. Returns -1 on error. */

float(float modidx, float framenum) frameduration = #277; /*
		Retrieves the duration (in seconds) of the specified framegroup. */

void(float buf, float fl) WriteFloat = #280;
string(float modidx, float framenum) frametoname = #284;
float(string name) checkcommand = #294; /*
		Checks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */

float(string effectname) particleeffectnum = #335; /*
		Precaches the named particle effect. If your effect name is of the form 'foo.bar' then particles/foo.cfg will be loaded by the client if foo.bar was not already defined.
		Different engines will have different particle systems, this specifies the QC API only. */

void(float effectnum, entity ent, vector start, vector end) trailparticles = #336; /*
		Draws the given effect between the two named points. If ent is not world, distances will be cached in the entity in order to avoid framerate dependancies. The entity is not otherwise used. */

void(float effectnum, vector origin, optional vector dir, optional float count) pointparticles = #337; /*
		Spawn a load of particles from the given effect at the given point traveling or aiming along the direction specified. The number of particles are scaled by the count argument. */

void(string s, ...) print = #339; /*
		Unconditionally print on the local system's console, even in ssqc (doesn't care about the value of the developer cvar). */

float(entity ent) wasfreed = #353; /*
		Quickly check to see if the entity is currently free. This function is only valid during the two-second non-reuse window, after that it may give bad results. Try one second to make it more robust. */

entity(entity from, optional entity to) copyentity = #400; /*
		Copies all fields from one entity to another. */

void(entity ent, float colours) setcolors = #401; /*
		Changes a player's colours. The bits 0-3 are the lower/trouser colour, bits 4-7 are the upper/shirt colours. */

entity(.string field, string match) findchain = #402;
entity(.float fld, float match) findchainfloat = #403;
void(vector org, vector dir, float count) te_blood = #405;
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlerain = #409;
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlesnow = #410;
void(vector org, optional float count) te_gunshot = #418;
void(vector org) te_spike = #419;
void(vector org) te_superspike = #420;
void(vector org) te_explosion = #421;
void(vector org) te_tarexplosion = #422;
void(vector org) te_wizspike = #423;
void(vector org) te_knightspike = #424;
void(vector org) te_lavasplash = #425;
void(vector org) te_teleport = #426;
void(vector org, float color, float colorlength) te_explosion2 = #427;
void(entity own, vector start, vector end) te_lightning1 = #428;
void(entity own, vector start, vector end) te_lightning2 = #429;
void(entity own, vector start, vector end) te_lightning3 = #430;
void(entity own, vector start, vector end) te_beam = #431;
void(vector dir) vectorvectors = #432;
float(entity e, float s) getsurfacenumpoints = #434;
vector(entity e, float s, float n) getsurfacepoint = #435;
vector(entity e, float s) getsurfacenormal = #436;
string(entity e, float s) getsurfacetexture = #437;
float(entity e, vector p) getsurfacenearpoint = #438;
vector(entity e, float s, vector p) getsurfaceclippedpoint = #439;
void(entity e, string s) clientcommand = #440;
float(string s) tokenize = #441;
string(float n) argv = #442;
float() argc = #0;
string(string cvarname) cvar_string = #448;
entity(entity start, .float fld, float match) findflags = #449;
entity(.float fld, float match) findchainflags = #450;
void(entity player) dropclient = #453;
entity() spawnclient = #454; /*
		Spawns a dummy player entity.
		Note that such dummy players will be carried from one map to the next.
		Warning: DP_SV_CLIENTCOLORS DP_SV_CLIENTNAME are not implemented in quakespasm, so use KRIMZON_SV_PARSECLIENTCOMMAND's clientcommand builtin to change the bot's name/colours/skin/team/etc, in the same way that clients would ask. */

float(entity client) clienttype = #455;
void(float target, string str) WriteUnterminatedString = #456;
entity(float entnum) edict_num = #459;
strbuf() buf_create = #460;
void(strbuf bufhandle) buf_del = #461;
float(strbuf bufhandle) buf_getsize = #462;
void(strbuf bufhandle_from, strbuf bufhandle_to) buf_copy = #463;
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #464;
string(strbuf bufhandle, string glue) buf_implode = #465;
string(strbuf bufhandle, float string_index) bufstr_get = #466;
void(strbuf bufhandle, float string_index, string str) bufstr_set = #467;
float(strbuf bufhandle, string str, float order) bufstr_add = #468;
void(strbuf bufhandle, float string_index) bufstr_free = #469;
float(float s) asin = #471;
float(float c) acos = #472;
float(float t) atan = #473;
float(float c, float s) atan2 = #474;
float(float a) tan = #475;
string(float uselocaltime, string format, ...) strftime = #478;
float(string s, string separator1, ...) tokenizebyseparator = #479;
string(string s) strtolower = #480;
string(string s) strtoupper = #481;
string(string s) cvar_defstring = #482;
void(vector origin, string sample, float volume, float attenuation) pointsound = #483;
string(string search, string replace, string subject) strreplace = #484;
string(string search, string replace, string subject) strireplace = #485;
vector(entity e, float s, float n, float a) getsurfacepointattribute = #486;
float(float caseinsensitive, string s, ...) crc16 = #494;
float(string name) cvar_type = #495;
float() numentityfields = #496; /*
		Gives the number of named entity fields. Note that this is not the size of an entity, but rather just the number of unique names (ie: vectors use 4 names rather than 3). */

float(string fieldname) findentityfield = #0; /*
		Find a field index by name. */

typedef .__variant field_t;
field_t(float fieldnum) entityfieldref = #0; /*
		Returns a field value that can be directly used to read entity fields. Be sure to validate the type with entityfieldtype before using. */

string(float fieldnum) entityfieldname = #497; /*
		Retrieves the name of the given entity field. */

float(float fieldnum) entityfieldtype = #498; /*
		Provides information about the type of the field specified by the field num. Returns one of the EV_ values. */

string(float fieldnum, entity ent) getentityfieldstring = #499;
float(float fieldnum, entity ent, string s) putentityfieldstring = #500;
string(string filename, optional float makereferenced) whichpack = #503; /*
		Returns the pak file name that contains the file specified. progs/player.mdl will generally return something like 'pak0.pak'. If makereferenced is true, clients will automatically be told that the returned package should be pre-downloaded and used, even if allow_download_refpackages is not set. */

string(string in) uri_escape = #510;
string(string in) uri_unescape = #511;
float(entity ent) num_for_edict = #512;
float(string str) tokenize_console = #514; /*
		Tokenize a string exactly as the console's tokenizer would do so. The regular tokenize builtin became bastardized for convienient string parsing, which resulted in a large disparity that can be exploited to bypass checks implemented in a naive SV_ParseClientCommand function, therefore you can use this builtin to make sure it exactly matches. */

float(float idx) argv_start_index = #515; /*
		Returns the character index that the tokenized arg started at. */

float(float idx) argv_end_index = #516; /*
		Returns the character index that the tokenized arg stopped at. */

string(string cvarname) cvar_description = #518; /*
		Retrieves the description of a cvar, which might be useful for tooltips or help files. This may still not be useful. */

float(optional float timetype) gettime = #519;
float(float v, optional float base) log = #532; /*
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(string filename, strbuf bufhandle) buf_loadfile = #535; /*
		Appends the named file into a string buffer (which must have been created in advance). The return value merely says whether the file was readable. */

float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536; /*
		Writes the contents of a string buffer onto the end of the supplied filehandle (you must have already used fopen). Additional optional arguments permit you to constrain the writes to a subsection of the stringbuffer. */

void(.../*, string funcname*/) callfunction = #605; /*
		Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */

float(string s) isfunction = #607; /*
		Returns true if the named function exists and can be called with the callfunction builtin. */

float(entity e, string s, optional float offset) parseentitydata = #613; /*
		Reads a single entity's fields into an already-spawned entity. s should contain field pairs like in a saved game: {"foo1" "bar" "foo2" "5"}. Returns <=0 on failure, otherwise returns the offset in the string that was read to. */

string(string fmt, ...) sprintf = #627;
float(entity e, float s) getsurfacenumtriangles = #628;
vector(entity e, float s, float n) getsurfacetriangle = #629;


//Builtin Stubs List (these are present for simpler compatibility, but not properly supported in QuakeSpasm at this time).
/*
void(vector org, string modelname, float startframe, float endframe, float framerate) effect = #404;
void(vector mincorner, vector maxcorner, float explosionspeed, float howmany) te_bloodshower = #406;
void(vector org, vector color) te_explosionrgb = #407;
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color, float gravityflag, float randomveljitter) te_particlecube = #408;
void(vector org, vector vel, float howmany) te_spark = #411;
void(vector org) te_gunshotquad = #412;
void(vector org) te_spikequad = #413;
void(vector org) te_superspikequad = #414;
void(vector org) te_explosionquad = #415;
void(vector org) te_smallflash = #416;
void(vector org, float radius, float lifetime, vector color) te_customflash = #417;
void(vector org) te_plasmaburn = #433;
void(entity e, entity tagentity, string tagname) setattachment = #443;
float(string s) strlennocol = #476;
string(string s) strdecolorize = #477;
*/


//Reset this back to normal.
#pragma noref 0
